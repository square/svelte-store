{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/persisted/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, type Updater, type Subscriber } from 'svelte/store';\nimport { StorageType, type StorageOptions, type Persisted } from './types.js';\nimport type { Loadable } from '../async-stores/types.js';\nimport { isLoadable, reloadAll } from '../utils/index.js';\nimport { writable } from '../standard-stores/index.js';\nimport {\n  getCookie,\n  getLocalStorageItem,\n  getSessionStorageItem,\n  setCookie,\n  setSessionStorageItem,\n  setLocalStorageItem,\n  removeSessionStorageItem,\n  removeCookie,\n  removeLocalStorageItem,\n} from './storage-utils.js';\n\ntype GetStorageItem = (key: string) => unknown;\ntype SetStorageItem = (key: string, value: unknown) => void;\ntype RemoveStorageItem = (key: string) => void;\n\ntype StorageFunctions = {\n  getStorageItem: GetStorageItem;\n  setStorageItem: SetStorageItem;\n  removeStorageItem: RemoveStorageItem;\n};\n\nconst builtinStorageFunctions: Record<string, StorageFunctions> = {\n  LOCAL_STORAGE: {\n    getStorageItem: getLocalStorageItem,\n    setStorageItem: setLocalStorageItem,\n    removeStorageItem: removeLocalStorageItem,\n  },\n  SESSION_STORAGE: {\n    getStorageItem: getSessionStorageItem,\n    setStorageItem: setSessionStorageItem,\n    removeStorageItem: removeSessionStorageItem,\n  },\n  COOKIE: {\n    getStorageItem: getCookie,\n    setStorageItem: setCookie,\n    removeStorageItem: removeCookie,\n  },\n};\n\nconst customStorageFunctions: Record<string, StorageFunctions> = {};\n\nexport const configureCustomStorageType = (\n  type: string,\n  storageFunctions: StorageFunctions\n): void => {\n  customStorageFunctions[type] = storageFunctions;\n};\n\nconst getStorageFunctions = (type: StorageType | string): StorageFunctions => {\n  const storageFunctions = {\n    ...builtinStorageFunctions,\n    ...customStorageFunctions,\n  }[type];\n  if (!storageFunctions) {\n    throw new Error(`'${type}' is not a valid StorageType!`);\n  }\n  return storageFunctions;\n};\n\ntype ConsentChecker = (consentLevel: unknown) => boolean;\n\nlet checkConsent: ConsentChecker;\n\nexport const configurePersistedConsent = (\n  consentChecker: ConsentChecker\n): void => {\n  checkConsent = consentChecker;\n};\n\n/**\n * Creates a `Writable` store that synchronizes with a localStorage item,\n * sessionStorage item, or cookie. The store's value will initialize to the value of\n * the corresponding storage item if found, otherwise it will use the provided initial\n * value and persist that value in storage. Any changes to the value of this store will\n * be persisted in storage.\n * @param initial The value to initialize to when used when a corresponding storage\n * item is not found. If a Loadable store is provided the store will be loaded and its value\n * used in this case.\n * @param key The key of the storage item to synchronize.\n * @param options Modifiers for store behavior.\n */\nexport const persisted = <T>(\n  initial: T | Loadable<T>,\n  key: string | (() => Promise<string>),\n  options: StorageOptions = {}\n): Persisted<T> => {\n  const { reloadable, storageType, consentLevel } = options;\n\n  const { getStorageItem, setStorageItem, removeStorageItem } =\n    getStorageFunctions(storageType || 'LOCAL_STORAGE');\n\n  const getKey = () => {\n    if (typeof key === 'function') {\n      return key();\n    }\n    return Promise.resolve(key);\n  };\n\n  const setAndPersist = async (value: T, set: Subscriber<T>) => {\n    // check consent if checker provided\n    if (!checkConsent || checkConsent(consentLevel)) {\n      const storageKey = await getKey();\n      setStorageItem(storageKey, value);\n    }\n    set(value);\n  };\n\n  const synchronize = async (set: Subscriber<T>): Promise<T> => {\n    const storageKey = await getKey();\n    const stored = getStorageItem(storageKey);\n\n    if (stored) {\n      set(stored as T);\n      return stored as T;\n    } else if (initial !== undefined) {\n      if (isLoadable(initial)) {\n        const $initial = await initial.load();\n        await setAndPersist($initial, set);\n\n        return $initial;\n      } else {\n        await setAndPersist(initial, set);\n\n        return initial;\n      }\n    } else {\n      set(undefined);\n      return undefined;\n    }\n  };\n\n  let initialSync: Promise<T>;\n\n  const thisStore = writable<T>(undefined, (set) => {\n    initialSync = synchronize(set);\n  });\n\n  const subscribe = thisStore.subscribe;\n\n  const set = async (value: T) => {\n    await initialSync;\n    return setAndPersist(value, thisStore.set);\n  };\n\n  const update = async (updater: Updater<T>) => {\n    await (initialSync ?? synchronize(thisStore.set));\n    const newValue = updater(get(thisStore));\n    await setAndPersist(newValue, thisStore.set);\n  };\n\n  const load = thisStore.load;\n\n  const resync = async (): Promise<T> => {\n    await initialSync;\n    return synchronize(thisStore.set);\n  };\n\n  const clear = async () => {\n    const storageKey = await getKey();\n    removeStorageItem(storageKey);\n    thisStore.set(null);\n  };\n\n  const reload = reloadable\n    ? async () => {\n        let newValue: T;\n\n        if (isLoadable(initial)) {\n          [newValue] = await reloadAll([initial]);\n        } else {\n          newValue = initial;\n        }\n\n        setAndPersist(newValue, thisStore.set);\n        return newValue;\n      }\n    : undefined;\n\n  return {\n    get store() {\n      return this;\n    },\n    subscribe,\n    set,\n    update,\n    load,\n    resync,\n    clear,\n    ...(reload && { reload }),\n  };\n};\n"]}