{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/standard-stores/index.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  derived as vanillaDerived,\n  get,\n  type Readable,\n  type StartStopNotifier,\n  type Subscriber,\n  type Unsubscriber,\n  type Updater,\n  type Writable,\n  writable as vanillaWritable,\n} from 'svelte/store';\nimport { anyReloadable, loadAll, reloadAll } from '../utils/index.js';\nimport type {\n  Loadable,\n  Stores,\n  StoresValues,\n  VisitedMap,\n} from '../async-stores/types.js';\nimport { flagStoreCreated } from '../config.js';\n\nconst loadDependencies = async <S extends Stores, T>(\n  thisStore: Readable<T>,\n  loadFunction: (stores: S) => Promise<unknown>,\n  stores: S\n): Promise<T> => {\n  // Create a dummy subscription when we load the store.\n  // This ensures that we will have at least one subscriber when\n  // loading the store so that our start function will run.\n  const dummyUnsubscribe = thisStore.subscribe(() => {\n    /* no-op */\n  });\n  try {\n    await loadFunction(stores);\n  } catch (error) {\n    dummyUnsubscribe();\n    throw error;\n  }\n  dummyUnsubscribe();\n  return get(thisStore);\n};\n\ntype DerivedMapper<S extends Stores, T> = (values: StoresValues<S>) => T;\ntype SubscribeMapper<S extends Stores, T> = (\n  values: StoresValues<S>,\n  set: (value: T) => void\n) => Unsubscriber | void;\n\n/**\n * A Derived store that is considered 'loaded' when all of its parents have loaded (and so on).\n * @param stores Any Readable or array of Readables used to generate the value of this store.\n * Any Loadable stores need to load before this store is considered loaded.\n * @param subscriberMapper A function that sets the value of the store.\n * @param initialValue Initial value\n * @returns A Loadable store that whose value is derived from the provided parent stores.\n * The loaded value of the store will be ready after awaiting the load function of this store.\n */\nexport function derived<S extends Stores, T>(\n  stores: S,\n  fn: SubscribeMapper<S, T>,\n  initialValue?: T\n): Loadable<T>;\n\n/**\n * A Derived store that is considered 'loaded' when all of its parents have loaded (and so on).\n * @param stores Any Readable or array of Readables used to generate the value of this store.\n * Any Loadable stores need to load before this store is considered loaded.\n * @param mappingFunction A function that maps the values of the parent store to the value of this store.\n * @param initialValue Initial value\n * @returns A Loadable store that whose value is derived from the provided parent stores.\n * The loaded value of the store will be ready after awaiting the load function of this store.\n */\nexport function derived<S extends Stores, T>(\n  stores: S,\n  mappingFunction: DerivedMapper<S, T>,\n  initialValue?: T\n): Loadable<T>;\n\n// eslint-disable-next-line func-style\nexport function derived<S extends Stores, T>(\n  stores: S,\n  fn: DerivedMapper<S, T> | SubscribeMapper<S, T>,\n  initialValue?: T\n): Loadable<T> {\n  flagStoreCreated();\n\n  const thisStore = vanillaDerived(stores, fn as any, initialValue);\n  const load = () => loadDependencies(thisStore, loadAll, stores);\n  const reload = anyReloadable(stores)\n    ? (visitedMap?: VisitedMap) => {\n        const visitMap = visitedMap ?? new WeakMap();\n        const reloadAndTrackVisits = (stores: S) => reloadAll(stores, visitMap);\n        return loadDependencies(thisStore, reloadAndTrackVisits, stores);\n      }\n    : undefined;\n\n  return {\n    get store() {\n      return this;\n    },\n    ...thisStore,\n    load,\n    ...(reload && { reload }),\n  };\n}\n\n/**\n * Create a `Writable` store that allows both updating and reading by subscription.\n * @param {*=}value initial value\n * @param {StartStopNotifier=}start start and stop notifications for subscriptions\n */\nexport const writable = <T>(\n  value?: T,\n  start?: StartStopNotifier<T>\n): Writable<T> & Loadable<T> => {\n  flagStoreCreated();\n  let hasEverLoaded = false;\n\n  let resolveLoadPromise: (value: T | PromiseLike<T>) => void;\n\n  let loadPromise: Promise<T> = new Promise((resolve) => {\n    resolveLoadPromise = (value: T | PromiseLike<T>) => {\n      hasEverLoaded = true;\n      resolve(value);\n    };\n  });\n\n  const updateLoadPromise = (value: T) => {\n    if (value === undefined && !hasEverLoaded) {\n      // don't resolve until we get a defined value\n      return;\n    }\n    resolveLoadPromise(value);\n    loadPromise = Promise.resolve(value);\n  };\n\n  const startFunction: StartStopNotifier<T> = (\n    set: Subscriber<T>,\n    update: (fn: Updater<T>) => void\n  ) => {\n    const customSet = (value: T) => {\n      set(value);\n      updateLoadPromise(value);\n    };\n    const customUpdate = (fn: Updater<T>) => {\n      update(fn);\n    };\n    // intercept the `set` function being passed to the provided start function\n    // instead provide our own `set` which also updates the load promise.\n    return start(customSet, customUpdate);\n  };\n\n  const thisStore = vanillaWritable(value, start && startFunction);\n\n  const load = async () => {\n    // Create a dummy subscription when we load the store.\n    // This ensures that we will have at least one subscriber when\n    // loading the store so that our start function will run.\n    const dummyUnsubscribe = thisStore.subscribe(() => {\n      /* no-op */\n    });\n    let loadedValue: T;\n    try {\n      loadedValue = await loadPromise;\n    } catch (error) {\n      dummyUnsubscribe();\n      throw error;\n    }\n    dummyUnsubscribe();\n    return loadedValue;\n  };\n\n  if (value !== undefined) {\n    // immeadietly load stores that are given an initial value\n    updateLoadPromise(value);\n  }\n\n  const set = (value: T) => {\n    thisStore.set(value);\n    updateLoadPromise(value);\n  };\n\n  const update = (updater: Updater<T>) => {\n    const newValue = updater(get(thisStore));\n    thisStore.set(newValue);\n    updateLoadPromise(newValue);\n  };\n\n  return {\n    get store() {\n      return this;\n    },\n    ...thisStore,\n    set,\n    update,\n    load,\n  };\n};\n\n/**\n * Creates a `Readable` store that allows reading by subscription.\n * @param value initial value\n * @param {StartStopNotifier}start start and stop notifications for subscriptions\n */\nexport const readable = <T>(\n  value?: T,\n  start?: StartStopNotifier<T>\n): Loadable<T> => {\n  const { subscribe, load } = writable(value, start);\n\n  return {\n    subscribe,\n    load,\n    get store() {\n      return this;\n    },\n  };\n};\n"]}