{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/async-stores/index.ts"],"names":[],"mappings":"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","sourcesContent":["import { get, type Updater, type Readable, writable } from 'svelte/store';\nimport type {\n  AsyncStoreOptions,\n  Loadable,\n  LoadState,\n  State,\n  Stores,\n  StoresValues,\n  WritableLoadable,\n  VisitedMap,\n} from './types.js';\nimport {\n  anyReloadable,\n  getStoresArray,\n  reloadAll,\n  loadAll,\n} from '../utils/index.js';\nimport { flagStoreCreated, getStoreTestingMode, logError } from '../config.js';\nimport { StartStopNotifier } from '../index.js';\n\n// STORES\n\nconst getLoadState = (stateString: Exclude<State, 'ERROR'>): LoadState => {\n  return {\n    isLoading: stateString === 'LOADING',\n    isReloading: stateString === 'RELOADING',\n    isLoaded: stateString === 'LOADED',\n    isWriting: stateString === 'WRITING',\n    isPending: stateString === 'LOADING' || stateString === 'RELOADING',\n    isSettled: stateString === 'LOADED',\n    isError: false,\n    error: null,\n  };\n};\n\nconst getErrorLoadState = (error: unknown): LoadState => {\n  return {\n    isLoading: false,\n    isReloading: false,\n    isLoaded: false,\n    isWriting: false,\n    isError: true,\n    isPending: false,\n    isSettled: true,\n    error,\n  };\n};\n\n/**\n * Generate a Loadable store that is considered 'loaded' after resolving synchronous or asynchronous behavior.\n * This behavior may be derived from the value of parent Loadable or non Loadable stores.\n * If so, this store will begin loading only after the parents have loaded.\n * This store is also writable. It includes a `set` function that will immediately update the value of the store\n * and then execute provided asynchronous behavior to persist this change.\n * @param stores Any readable or array of Readables whose value is used to generate the asynchronous behavior of this store.\n * Any changes to the value of these stores post-load will restart the asynchronous behavior of the store using the new values.\n * @param mappingLoadFunction A function that takes in the values of the stores and generates a Promise that resolves\n * to the final value of the store when the asynchronous behavior is complete.\n * @param mappingWriteFunction A function that takes in the new value of the store and uses it to perform async behavior.\n * Typically this would be to persist the change. If this value resolves to a value the store will be set to it.\n * @param options Modifiers for store behavior.\n * @param start Start stop notifier.\n * @returns A Loadable store whose value is set to the resolution of provided async behavior.\n * The loaded value of the store will be ready after awaiting the load function of this store.\n */\nexport const asyncWritable = <S extends Stores, T>(\n  stores: S,\n  mappingLoadFunction: (values: StoresValues<S>) => Promise<T> | T,\n  mappingWriteFunction?: (\n    value: T,\n    parentValues?: StoresValues<S>,\n    oldValue?: T\n  ) => Promise<void | T>,\n  options: AsyncStoreOptions<T> = {},\n  start: StartStopNotifier<T> = undefined\n): WritableLoadable<T> => {\n  flagStoreCreated();\n  const { reloadable, trackState, initial } = options;\n\n  const loadState = trackState\n    ? writable<LoadState>(getLoadState('LOADING'))\n    : undefined;\n\n  const setState = (state: Exclude<State, 'ERROR'>) =>\n    loadState?.set(getLoadState(state));\n\n  const setErrorState = (error: any) =>\n    loadState?.set(getErrorLoadState(error));\n\n  // stringified representation of parents' loaded values\n  // used to track whether a change has occurred and the store reloaded\n  let loadedValuesString: string;\n\n  let latestLoadAndSet: () => Promise<T>;\n\n  // most recent call of mappingLoadFunction, including resulting side effects\n  // (updating store value, tracking state, etc)\n  let currentLoadPromise: Promise<T>;\n\n  const tryLoad = async (values: StoresValues<S>) => {\n    try {\n      return await mappingLoadFunction(values);\n    } catch (e) {\n      if (e.name !== 'AbortError') {\n        logError(e);\n        setErrorState(e);\n      }\n      throw e;\n    }\n  };\n\n  // eslint-disable-next-line prefer-const\n  let loadDependenciesThenSet: (\n    parentLoadFunction: (stores: S) => Promise<StoresValues<S>>,\n    forceReload?: boolean\n  ) => Promise<T>;\n\n  const thisStore = writable(initial, (set, update) => {\n    loadDependenciesThenSet(loadAll).catch(() => Promise.resolve());\n\n    const parentUnsubscribers = getStoresArray(stores).map((store) =>\n      store.subscribe(() => {\n        loadDependenciesThenSet(loadAll).catch(() => Promise.resolve());\n      })\n    );\n\n    const callback = start && start(set, update);\n    return () => {\n      callback && callback();\n      parentUnsubscribers.map((unsubscriber) => unsubscriber());\n    };\n  });\n\n  loadDependenciesThenSet = async (\n    parentLoadFunction: (stores: S) => Promise<StoresValues<S>>,\n    forceReload = false\n  ) => {\n    const loadParentStores = parentLoadFunction(stores);\n\n    try {\n      await loadParentStores;\n    } catch (e) {\n      currentLoadPromise = loadParentStores as Promise<T>;\n      setErrorState(e);\n      return currentLoadPromise;\n    }\n\n    const storeValues = getStoresArray(stores).map((store) =>\n      get(store)\n    ) as StoresValues<S>;\n\n    if (!forceReload) {\n      const newValuesString = JSON.stringify(storeValues);\n      if (newValuesString === loadedValuesString) {\n        // no change, don't generate new promise\n        return currentLoadPromise;\n      }\n      loadedValuesString = newValuesString;\n    }\n\n    // convert storeValues to single store value if expected by mapping function\n    const loadInput = Array.isArray(stores) ? storeValues : storeValues[0];\n\n    const loadAndSet = async () => {\n      latestLoadAndSet = loadAndSet;\n      if (get(loadState)?.isSettled) {\n        setState('RELOADING');\n      }\n      try {\n        const finalValue = await tryLoad(loadInput);\n        thisStore.set(finalValue);\n        setState('LOADED');\n        return finalValue;\n      } catch (e) {\n        // if a load is aborted, resolve to the current value of the store\n        if (e.name === 'AbortError') {\n          // Normally when a load is aborted we want to leave the state as is.\n          // However if the latest load is aborted we change back to LOADED\n          // so that it does not get stuck LOADING/RELOADIN'.\n          if (loadAndSet === latestLoadAndSet) {\n            setState('LOADED');\n          }\n          return get(thisStore);\n        }\n        throw e;\n      }\n    };\n\n    currentLoadPromise = loadAndSet();\n    return currentLoadPromise;\n  };\n\n  const setStoreValueThenWrite = async (\n    updater: Updater<T>,\n    persist?: boolean\n  ) => {\n    setState('WRITING');\n    let oldValue: T;\n    try {\n      oldValue = await loadDependenciesThenSet(loadAll);\n    } catch {\n      oldValue = get(thisStore);\n    }\n    const newValue = updater(oldValue);\n    currentLoadPromise = currentLoadPromise\n      .then(() => newValue)\n      .catch(() => newValue);\n    thisStore.set(newValue);\n\n    if (mappingWriteFunction && persist) {\n      try {\n        const parentValues = await loadAll(stores);\n\n        const writeResponse = (await mappingWriteFunction(\n          newValue,\n          parentValues,\n          oldValue\n        )) as T;\n\n        if (writeResponse !== undefined) {\n          thisStore.set(writeResponse);\n          currentLoadPromise = currentLoadPromise.then(() => writeResponse);\n        }\n      } catch (e) {\n        logError(e);\n        setErrorState(e);\n        throw e;\n      }\n    }\n    setState('LOADED');\n  };\n\n  // required properties\n  const subscribe = thisStore.subscribe;\n  const set = (newValue: T, persist = true) =>\n    setStoreValueThenWrite(() => newValue, persist);\n  const update = (updater: Updater<T>, persist = true) =>\n    setStoreValueThenWrite(updater, persist);\n  const load = () => loadDependenciesThenSet(loadAll);\n\n  // // optional properties\n  const hasReloadFunction = Boolean(reloadable || anyReloadable(stores));\n  const reload = hasReloadFunction\n    ? async (visitedMap?: VisitedMap) => {\n        const visitMap = visitedMap ?? new WeakMap();\n        const reloadAndTrackVisits = (stores: S) => reloadAll(stores, visitMap);\n        setState('RELOADING');\n        const result = await loadDependenciesThenSet(\n          reloadAndTrackVisits,\n          reloadable\n        );\n        setState('LOADED');\n        return result;\n      }\n    : undefined;\n\n  const state: Readable<LoadState> = loadState\n    ? { subscribe: loadState.subscribe }\n    : undefined;\n  const reset = getStoreTestingMode()\n    ? () => {\n        thisStore.set(initial);\n        setState('LOADING');\n        loadedValuesString = undefined;\n        currentLoadPromise = undefined;\n      }\n    : undefined;\n\n  return {\n    get store() {\n      return this;\n    },\n    subscribe,\n    set,\n    update,\n    load,\n    ...(reload && { reload }),\n    ...(state && { state }),\n    ...(reset && { reset }),\n  };\n};\n\n/**\n * Generate a Loadable store that is considered 'loaded' after resolving asynchronous behavior.\n * This asynchronous behavior may be derived from the value of parent Loadable or non Loadable stores.\n * If so, this store will begin loading only after the parents have loaded.\n * @param stores Any readable or array of Readables whose value is used to generate the asynchronous behavior of this store.\n * Any changes to the value of these stores post-load will restart the asynchronous behavior of the store using the new values.\n * @param mappingLoadFunction A function that takes in the values of the stores and generates a Promise that resolves\n * to the final value of the store when the asynchronous behavior is complete.\n * @param options Modifiers for store behavior.\n * @returns A Loadable store whose value is set to the resolution of provided async behavior.\n * The loaded value of the store will be ready after awaiting the load function of this store.\n */\nexport const asyncDerived = <S extends Stores, T>(\n  stores: S,\n  mappingLoadFunction: (values: StoresValues<S>) => Promise<T>,\n  options?: AsyncStoreOptions<T>\n): Loadable<T> => {\n  const { store, subscribe, load, reload, state, reset } = asyncWritable(\n    stores,\n    mappingLoadFunction,\n    undefined,\n    options\n  );\n\n  return {\n    store,\n    subscribe,\n    load,\n    ...(reload && { reload }),\n    ...(state && { state }),\n    ...(reset && { reset }),\n  };\n};\n\n/**\n * Generates a Loadable store that will start asynchronous behavior when subscribed to,\n * and whose value will be equal to the resolution of that behavior when completed.\n * @param initial The initial value of the store before it has loaded or upon load failure.\n * @param loadFunction A function that generates a Promise that resolves to the final value\n * of the store when the asynchronous behavior is complete.\n * @param options Modifiers for store behavior.\n * @returns  A Loadable store whose value is set to the resolution of provided async behavior.\n * The loaded value of the store will be ready after awaiting the load function of this store.\n */\nexport const asyncReadable = <T>(\n  initial: T,\n  loadFunction: () => Promise<T>,\n  options?: Omit<AsyncStoreOptions<T>, 'initial'>\n): Loadable<T> => {\n  return asyncDerived([], loadFunction, { ...options, initial });\n};\n"]}